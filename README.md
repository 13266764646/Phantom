# ss-im

## 介绍
牛逼IM系统

## 软件架构

## 构建

1. 项目使用了Lombok, 需要安装IDEA lombok 插件
2. 项目使用IDEA的Protobuf插件，需要执行一下命令
    
    cd im-common && mvn protobuf:compile


| 功能 | 进度 |
| --- | --- |
| 认证 | 已完成 |
| 单聊消息 | 已完成 |
| timeline模型 | 已完成 |  
| 群聊消息 | 已完成 |
| 创建群组 | 已完成 | 
| IPlist | 未开始 | 
| 单点登录SSO、JWT | 未开始|
| 消息分库分表 | 未开始 |
| 发红包 | 未开始 |
 

### 系统整体流程图
![](http://assets.processon.com/chart_image/5db6cb2ce4b0335f1e4338ef.png)

### 认证流程图

![](http://assets.processon.com/chart_image/5dc53e6ce4b005b5778bd235.png)

### 单聊、群聊

1. 离线消息

离线消息读取频率高

写扩散策略：发送消息之后，先把离线消息写入redis中，然后推送消息，推送成功，就删除消息。
群聊的消息在保存离线消息的时候，为群里每一个人都保一条记录，这样可以保证每个人的消息保存在redis cluster中的不同机器上，
根据senderid哈希，缓解每台机器的压力。

基于Redis的SortedSet存储离线消息


2. 历史消息

历史消息落地数据库，走读扩散原则。就是一条群消息保存到数据库中是一条记录，每个人去拉取群消息的时候，就读到这条消息。

因为历史消息是非常低频的访问行为，所以这个走读扩散原则。

3. 消息分库分表方案

单聊消息，根据senderid做分区key。同步AB的消息，先找出A发送给B的消息，然后找出B发送给A的消息。都会路由到同一个数据库的同一个表

群聊消息：根据grouid做分区key。同一个群聊的消息都路由到同一个数据库的同一个表中。

4. messageId唯一ID生成

采用Snowflake算法生成唯一ID

### 消息timeline模型

![](http://assets.processon.com/chart_image/5dc905e1e4b0ffd214440983.png)

Timeline模型类似每个人都有一个离线消息队列，对于多端来说，为每一个端维护一个同步的offset，每次抓取数据的时候从offset开始抓。

从而实现多端离线消息同步的功能。


目前的实现方式是在服务端为每个用户生成一个严格的消息sequence,然后在客户端发送消息的时候，

分发系统的processor、kafka的partition都会根据接收者Id进行hash路由，确保消息发送的顺序

**这种实现方式对于群聊消息无法保证绝对有序**


### zookeeper工作流程

1. 客户端获取分发系统ip地址场景

接入系统启动的时候往zookeeper中注册，客户端启动的时候根据接口获取其中一个接入系统的ip地址。

如果客户端和接入系统断开连接，则继续选择一个服务重新连接


2. 接入系统获取分发系统地址列表场景

分发系统启动的时候往zookeeper中注册，接入系统会从zookeeper中获取到一个分发系统的ip地址。

断开连接会无限重连。


### 单点登录方案

基于SSO单点登录系统实现用户认证，生成JWT串，在分发系统可以直接基于secret解密JWT从而实现认证功能。

### 容错性分析

1. 客户端网络环境不好，挂了怎么处理

1.1 客户端挂了，接入系统会移除session、包括redis中的session。等待客户端重新连接。
1.2 在客户端挂了这段时间，分发系统发送消息的时候会发现推送不成功，此时要放入离线消息


2. 接入系统挂了怎么处理

2.1 对于分发系统来说，通过zookeeper感知到，需要移除分发系统实例。但是此时会发现有些消息推送对应的接入系统找不到了，
此时消息进入队列或者离线消息。等待客户端重新连接的时候，发起认证，更新了接入系统的地址，再将消息推送过去

2.2 对于客户端来说，分发系统挂了，则继续从zookeeper中查找下一个可用的接入系统地址，发起连接，重新认证。

3. 分发系统挂了怎么处理

3.1 对于接入系统来说，通过zookeeper感知到，需要移除分发系统的实例。



#### 参与贡献

中华石杉

